#!/usr/bin/env node

'use strict';

var call       = Function.prototype.call
  , keys       = Object.keys
  , fs         = require('fs')
  , resolve    = require('path').resolve
  , commonLeft = require('es5-ext/lib/Array/prototype/common-left')
  , flatten    = require('es5-ext/lib/Array/prototype/flatten')
  , copy       = require('es5-ext/lib/Object/copy')
  , mapKeys    = require('es5-ext/lib/Object/map-keys')
  , merge      = require('es5-ext/lib/Object/merge')
  , deferred   = require('deferred')
  , clc        = require('cli-color')
  , bold       = clc.bold, red = clc.bold.red, green = clc.bold.green
  , reporter   = require("../lib/reporter")
  , lintPath   = require("../lib/lint-path")
  , options    = require('../lib/_options-schema')

  , opts = require('optimist').usage("Usage: $0 <options> <paths>...",
		merge(copy(options), {
			color: {
				boolean: true,
				default: true,
				description: "(Non JSLint) Colorize output"
			},
			git: {
				boolean: true,
				description: "(Non JSLint) Obey .gitignore rules "
					+ "(only when called on directory)"
			},
			help: {
				boolean: true,
				desription: "(Non JSLint) Show this help"
			},
			maxerrfiles: {
				default: 5,
				description: "(Non JSLint) Maximum number of files for "
					+ "which warnings are reported"
			},
			nocache: {
				boolean: true,
				description: "(Non JSLint) Whether to cache results (useful when "
					+ "called repeatedly)"
			}
		}))

  , argv = opts.argv
  , paths = argv._;

if (argv.help) {
	console.log(opts.help());
	process.exit(0);
}

delete argv._;
delete argv.$0;

deferred.map(paths.length ? paths : ['.'], function (path) {
	path = resolve(path);
	return lintPath(path, argv).invoke(function () {
		return mapKeys(this, function (key) {
			return (key === '.') ? path : resolve(path, key);
		});
	});
}).invoke('reduce', function (all, one) {
	return merge(all, one);
}, {})(function (files) {
	var paths = keys(files), index;
	if (!paths.length) {
		console.log('Found no files to lint');
		return 0;
	}
	if (paths.length === 1) {
		reporter(paths[0], files[paths[0]]);
		return files[paths[0]].errors ? 1 : 0
	}

	index = call.apply(commonLeft, paths);
	paths = paths.filter(function (path) {
		return files[path].errors;
	});
	if (paths.length) {
		paths.slice(0, argv.maxerrfiles).forEach(function (filename) {
			reporter(filename.slice(index), files[filename]);
		});
		if (paths.length > argv.maxerrfiles) {
			console.log(red("... and more errors in " +
				(paths.length - argv.maxerrfiles) + " files.\n"));
		}
		return 1;
	} else {
		console.log(bold("All is") + " " + green("OK"));
		return 0;
	}
}).end(function (code) {
	process.on('exit', function () {
		process.exit(code);
	});
}, null);
